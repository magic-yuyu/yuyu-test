// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: internal_client.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const activateInternalClient = `-- name: ActivateInternalClient :exec
UPDATE internal_clients SET is_active = true, updated_at = CURRENT_TIMESTAMP WHERE client_id = $1
`

func (q *Queries) ActivateInternalClient(ctx context.Context, clientID string) error {
	_, err := q.db.ExecContext(ctx, activateInternalClient, clientID)
	return err
}

const checkClientHasScope = `-- name: CheckClientHasScope :one
SELECT EXISTS(
    SELECT 1 FROM client_scopes cs
    JOIN scopes s ON cs.scope_id = s.id
    WHERE cs.client_id = $1 AND s.scope_name = $2 AND s.is_active = true
) as has_scope
`

type CheckClientHasScopeParams struct {
	ClientID  string `json:"client_id"`
	ScopeName string `json:"scope_name"`
}

func (q *Queries) CheckClientHasScope(ctx context.Context, arg CheckClientHasScopeParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkClientHasScope, arg.ClientID, arg.ScopeName)
	var has_scope bool
	err := row.Scan(&has_scope)
	return has_scope, err
}

const cleanupExpiredTokens = `-- name: CleanupExpiredTokens :exec
DELETE FROM service_tokens WHERE expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) CleanupExpiredTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupExpiredTokens)
	return err
}

const createInternalClient = `-- name: CreateInternalClient :one
INSERT INTO internal_clients (client_id, client_secret_hash, service_name, description)
VALUES ($1, $2, $3, $4)
RETURNING client_id, client_secret_hash, service_name, description, is_active, created_at, updated_at
`

type CreateInternalClientParams struct {
	ClientID         string         `json:"client_id"`
	ClientSecretHash string         `json:"client_secret_hash"`
	ServiceName      string         `json:"service_name"`
	Description      sql.NullString `json:"description"`
}

func (q *Queries) CreateInternalClient(ctx context.Context, arg CreateInternalClientParams) (InternalClient, error) {
	row := q.db.QueryRowContext(ctx, createInternalClient,
		arg.ClientID,
		arg.ClientSecretHash,
		arg.ServiceName,
		arg.Description,
	)
	var i InternalClient
	err := row.Scan(
		&i.ClientID,
		&i.ClientSecretHash,
		&i.ServiceName,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createScope = `-- name: CreateScope :one
INSERT INTO scopes (scope_name, description)
VALUES ($1, $2)
RETURNING id, scope_name, description, is_active, created_at
`

type CreateScopeParams struct {
	ScopeName   string         `json:"scope_name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateScope(ctx context.Context, arg CreateScopeParams) (Scope, error) {
	row := q.db.QueryRowContext(ctx, createScope, arg.ScopeName, arg.Description)
	var i Scope
	err := row.Scan(
		&i.ID,
		&i.ScopeName,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateInternalClient = `-- name: DeactivateInternalClient :exec
UPDATE internal_clients SET is_active = false, updated_at = CURRENT_TIMESTAMP WHERE client_id = $1
`

func (q *Queries) DeactivateInternalClient(ctx context.Context, clientID string) error {
	_, err := q.db.ExecContext(ctx, deactivateInternalClient, clientID)
	return err
}

const deactivateScope = `-- name: DeactivateScope :exec
UPDATE scopes SET is_active = false WHERE scope_name = $1
`

func (q *Queries) DeactivateScope(ctx context.Context, scopeName string) error {
	_, err := q.db.ExecContext(ctx, deactivateScope, scopeName)
	return err
}

const deleteInternalClient = `-- name: DeleteInternalClient :exec
DELETE FROM internal_clients WHERE client_id = $1
`

func (q *Queries) DeleteInternalClient(ctx context.Context, clientID string) error {
	_, err := q.db.ExecContext(ctx, deleteInternalClient, clientID)
	return err
}

const getClientScopes = `-- name: GetClientScopes :many
SELECT s.id, s.scope_name, s.description, cs.granted_at, cs.granted_by
FROM client_scopes cs
JOIN scopes s ON cs.scope_id = s.id
WHERE cs.client_id = $1 AND s.is_active = true
ORDER BY s.scope_name
`

type GetClientScopesRow struct {
	ID          int32          `json:"id"`
	ScopeName   string         `json:"scope_name"`
	Description sql.NullString `json:"description"`
	GrantedAt   time.Time      `json:"granted_at"`
	GrantedBy   sql.NullString `json:"granted_by"`
}

func (q *Queries) GetClientScopes(ctx context.Context, clientID string) ([]GetClientScopesRow, error) {
	rows, err := q.db.QueryContext(ctx, getClientScopes, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClientScopesRow{}
	for rows.Next() {
		var i GetClientScopesRow
		if err := rows.Scan(
			&i.ID,
			&i.ScopeName,
			&i.Description,
			&i.GrantedAt,
			&i.GrantedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientStatistics = `-- name: GetClientStatistics :one
SELECT 
    COUNT(*) as total_requests,
    AVG(response_time_ms) as avg_response_time,
    COUNT(CASE WHEN status_code >= 400 THEN 1 END) as error_count
FROM service_access_logs 
WHERE client_id = $1 AND created_at >= $2
`

type GetClientStatisticsParams struct {
	ClientID  string    `json:"client_id"`
	CreatedAt time.Time `json:"created_at"`
}

type GetClientStatisticsRow struct {
	TotalRequests   int64   `json:"total_requests"`
	AvgResponseTime float64 `json:"avg_response_time"`
	ErrorCount      int64   `json:"error_count"`
}

func (q *Queries) GetClientStatistics(ctx context.Context, arg GetClientStatisticsParams) (GetClientStatisticsRow, error) {
	row := q.db.QueryRowContext(ctx, getClientStatistics, arg.ClientID, arg.CreatedAt)
	var i GetClientStatisticsRow
	err := row.Scan(&i.TotalRequests, &i.AvgResponseTime, &i.ErrorCount)
	return i, err
}

const getInternalClient = `-- name: GetInternalClient :one
SELECT client_id, client_secret_hash, service_name, description, is_active, created_at, updated_at FROM internal_clients WHERE client_id = $1 AND is_active = true
`

func (q *Queries) GetInternalClient(ctx context.Context, clientID string) (InternalClient, error) {
	row := q.db.QueryRowContext(ctx, getInternalClient, clientID)
	var i InternalClient
	err := row.Scan(
		&i.ClientID,
		&i.ClientSecretHash,
		&i.ServiceName,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInternalClientByID = `-- name: GetInternalClientByID :one
SELECT client_id, client_secret_hash, service_name, description, is_active, created_at, updated_at FROM internal_clients WHERE client_id = $1
`

func (q *Queries) GetInternalClientByID(ctx context.Context, clientID string) (InternalClient, error) {
	row := q.db.QueryRowContext(ctx, getInternalClientByID, clientID)
	var i InternalClient
	err := row.Scan(
		&i.ClientID,
		&i.ClientSecretHash,
		&i.ServiceName,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getScopeByName = `-- name: GetScopeByName :one
SELECT id, scope_name, description, is_active, created_at FROM scopes WHERE scope_name = $1 AND is_active = true
`

func (q *Queries) GetScopeByName(ctx context.Context, scopeName string) (Scope, error) {
	row := q.db.QueryRowContext(ctx, getScopeByName, scopeName)
	var i Scope
	err := row.Scan(
		&i.ID,
		&i.ScopeName,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getServiceAccessLogs = `-- name: GetServiceAccessLogs :many
SELECT id, client_id, endpoint, method, status_code, response_time_ms, ip_address, user_agent, request_body, response_body, created_at FROM service_access_logs 
WHERE client_id = $1 
ORDER BY created_at DESC 
LIMIT $2 OFFSET $3
`

type GetServiceAccessLogsParams struct {
	ClientID string `json:"client_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) GetServiceAccessLogs(ctx context.Context, arg GetServiceAccessLogsParams) ([]ServiceAccessLog, error) {
	rows, err := q.db.QueryContext(ctx, getServiceAccessLogs, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ServiceAccessLog{}
	for rows.Next() {
		var i ServiceAccessLog
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Endpoint,
			&i.Method,
			&i.StatusCode,
			&i.ResponseTimeMs,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestBody,
			&i.ResponseBody,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceToken = `-- name: GetServiceToken :one
SELECT id, client_id, token_hash, scopes, expires_at, is_revoked, created_at FROM service_tokens 
WHERE token_hash = $1 AND expires_at > CURRENT_TIMESTAMP AND is_revoked = false
`

func (q *Queries) GetServiceToken(ctx context.Context, tokenHash string) (ServiceToken, error) {
	row := q.db.QueryRowContext(ctx, getServiceToken, tokenHash)
	var i ServiceToken
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.TokenHash,
		pq.Array(&i.Scopes),
		&i.ExpiresAt,
		&i.IsRevoked,
		&i.CreatedAt,
	)
	return i, err
}

const grantScopeToClient = `-- name: GrantScopeToClient :exec
INSERT INTO client_scopes (client_id, scope_id, granted_by)
VALUES ($1, $2, $3)
ON CONFLICT (client_id, scope_id) DO NOTHING
`

type GrantScopeToClientParams struct {
	ClientID  string         `json:"client_id"`
	ScopeID   int32          `json:"scope_id"`
	GrantedBy sql.NullString `json:"granted_by"`
}

func (q *Queries) GrantScopeToClient(ctx context.Context, arg GrantScopeToClientParams) error {
	_, err := q.db.ExecContext(ctx, grantScopeToClient, arg.ClientID, arg.ScopeID, arg.GrantedBy)
	return err
}

const listAllScopes = `-- name: ListAllScopes :many
SELECT id, scope_name, description, is_active, created_at FROM scopes WHERE is_active = true ORDER BY scope_name
`

func (q *Queries) ListAllScopes(ctx context.Context) ([]Scope, error) {
	rows, err := q.db.QueryContext(ctx, listAllScopes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Scope{}
	for rows.Next() {
		var i Scope
		if err := rows.Scan(
			&i.ID,
			&i.ScopeName,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInternalClients = `-- name: ListInternalClients :many
SELECT client_id, client_secret_hash, service_name, description, is_active, created_at, updated_at FROM internal_clients WHERE is_active = true ORDER BY created_at DESC
`

func (q *Queries) ListInternalClients(ctx context.Context) ([]InternalClient, error) {
	rows, err := q.db.QueryContext(ctx, listInternalClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InternalClient{}
	for rows.Next() {
		var i InternalClient
		if err := rows.Scan(
			&i.ClientID,
			&i.ClientSecretHash,
			&i.ServiceName,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logServiceAccess = `-- name: LogServiceAccess :exec
INSERT INTO service_access_logs (
    client_id, endpoint, method, status_code, response_time_ms, 
    ip_address, user_agent, request_body, response_body
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type LogServiceAccessParams struct {
	ClientID       string         `json:"client_id"`
	Endpoint       string         `json:"endpoint"`
	Method         string         `json:"method"`
	StatusCode     int32          `json:"status_code"`
	ResponseTimeMs sql.NullInt32  `json:"response_time_ms"`
	IpAddress      pqtype.Inet    `json:"ip_address"`
	UserAgent      sql.NullString `json:"user_agent"`
	RequestBody    sql.NullString `json:"request_body"`
	ResponseBody   sql.NullString `json:"response_body"`
}

func (q *Queries) LogServiceAccess(ctx context.Context, arg LogServiceAccessParams) error {
	_, err := q.db.ExecContext(ctx, logServiceAccess,
		arg.ClientID,
		arg.Endpoint,
		arg.Method,
		arg.StatusCode,
		arg.ResponseTimeMs,
		arg.IpAddress,
		arg.UserAgent,
		arg.RequestBody,
		arg.ResponseBody,
	)
	return err
}

const revokeScopeFromClient = `-- name: RevokeScopeFromClient :exec
DELETE FROM client_scopes WHERE client_id = $1 AND scope_id = $2
`

type RevokeScopeFromClientParams struct {
	ClientID string `json:"client_id"`
	ScopeID  int32  `json:"scope_id"`
}

func (q *Queries) RevokeScopeFromClient(ctx context.Context, arg RevokeScopeFromClientParams) error {
	_, err := q.db.ExecContext(ctx, revokeScopeFromClient, arg.ClientID, arg.ScopeID)
	return err
}

const revokeServiceToken = `-- name: RevokeServiceToken :exec
UPDATE service_tokens SET is_revoked = true WHERE token_hash = $1
`

func (q *Queries) RevokeServiceToken(ctx context.Context, tokenHash string) error {
	_, err := q.db.ExecContext(ctx, revokeServiceToken, tokenHash)
	return err
}

const storeServiceToken = `-- name: StoreServiceToken :exec
INSERT INTO service_tokens (client_id, token_hash, scopes, expires_at)
VALUES ($1, $2, $3, $4)
`

type StoreServiceTokenParams struct {
	ClientID  string    `json:"client_id"`
	TokenHash string    `json:"token_hash"`
	Scopes    []string  `json:"scopes"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) StoreServiceToken(ctx context.Context, arg StoreServiceTokenParams) error {
	_, err := q.db.ExecContext(ctx, storeServiceToken,
		arg.ClientID,
		arg.TokenHash,
		pq.Array(arg.Scopes),
		arg.ExpiresAt,
	)
	return err
}

const updateInternalClient = `-- name: UpdateInternalClient :one
UPDATE internal_clients 
SET service_name = $2, description = $3, updated_at = CURRENT_TIMESTAMP
WHERE client_id = $1 AND is_active = true
RETURNING client_id, client_secret_hash, service_name, description, is_active, created_at, updated_at
`

type UpdateInternalClientParams struct {
	ClientID    string         `json:"client_id"`
	ServiceName string         `json:"service_name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) UpdateInternalClient(ctx context.Context, arg UpdateInternalClientParams) (InternalClient, error) {
	row := q.db.QueryRowContext(ctx, updateInternalClient, arg.ClientID, arg.ServiceName, arg.Description)
	var i InternalClient
	err := row.Scan(
		&i.ClientID,
		&i.ClientSecretHash,
		&i.ServiceName,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateScope = `-- name: UpdateScope :one
UPDATE scopes 
SET description = $2
WHERE scope_name = $1 AND is_active = true
RETURNING id, scope_name, description, is_active, created_at
`

type UpdateScopeParams struct {
	ScopeName   string         `json:"scope_name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) UpdateScope(ctx context.Context, arg UpdateScopeParams) (Scope, error) {
	row := q.db.QueryRowContext(ctx, updateScope, arg.ScopeName, arg.Description)
	var i Scope
	err := row.Scan(
		&i.ID,
		&i.ScopeName,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}
