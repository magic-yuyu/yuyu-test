### **认证服务(Auth Service)技术实现与设计方案**

#### **1. 服务定位与核心职责**

**认证服务 (Auth Service)** 是我们整个SaaS平台的安全中枢和信任根。它是一个独立的、高可用的核心微服务，其职责边界清晰且唯一：**管理和验证所有实体（包括终端用户和服务）的身份，并签发证明其身份和权限的令牌。**

它的核心职责分为两大块：

1. **IDaaS - 对外用户认证**:
    
    - **租户管理**: 负责客户（租户）的API密钥生成与安全管理。
        
    - **终端用户生命周期**: 处理所有租户下的终端用户的注册、登录、密码重置等身份相关操作。
        
    - **用户会话管理**: 为通过验证的终端用户签发和解析JWT（JSON Web Tokens），用于在客户应用中维持会话。
        
2. **M2M - 对内服务认证**:
    
    - **服务身份管理**: 注册和管理内部微服务（如计费服务、任务服务）的身份凭证 (`client_id`, `client_secret`)。
        
    - **服务令牌签发**: 为通过验证的内部服务签发专用的、具有特定权限（Scopes）的JWT，用于服务间的安全通信。
        
    - **权限(Scope)管理**: 作为权限的中央存储库，定义系统中所有可用的操作权限。
        

**本服务不负责**：管理用户除身份凭证外的详细个人资料、处理计费逻辑、管理AI任务等。

#### **2. 技术栈选型**

| 类别            | 技术选型                             | 优势                                           |
| ------------- | -------------------------------- | -------------------------------------------- |
| **语言**        | **Go (Golang)**                  | 极致的性能与并发能力，编译为静态二进制文件，部署简单。                  |
| **Web框架**     | **Gin**                          | 高性能、API简洁，拥有出色的路由和中间件支持。                     |
| **数据库**       | **PostgreSQL**                   | 功能强大，支持事务和行级安全，是构建多租户应用的最佳选择。                |
| **ORM/数据库驱动** | **sqlc**                         | sqlc从原生SQL生成类型安全的Go代码，兼顾性能与安全；pgx是最高性能的底层驱动。 |
| **密码哈希**      | **`golang.org/x/crypto/bcrypt`** | Go官方提供的加密库，安全可靠，是密码存储的行业标准。                  |
| **身份令牌**      | **`golang-jwt/jwt/v5`**          | Go社区最流行的JWT库，用于生成和验证令牌。                      |

#### **3. 数据库设计 (Auth Service专属)**

本服务拥有自己独立的数据库，用于存储所有与身份和权限相关的核心数据。

```
-- 表: tenants
-- 描述: 存储我们的客户（租户）信息。
CREATE TABLE tenants (
    id VARCHAR(255) PRIMARY KEY, -- 租户ID, e.g., tnt_...
    name VARCHAR(255) NOT NULL, -- 客户的应用名称
    api_public_key VARCHAR(255) UNIQUE NOT NULL, -- 用于客户端调用的可公开密钥
    api_secret_key_hash VARCHAR(255) NOT NULL, -- 用于服务器间调用的密钥的bcrypt哈希值
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- 表: users
-- 描述: 存储所有租户的终端用户。
CREATE TABLE users (
    id VARCHAR(255) PRIMARY KEY, -- 全局唯一的用户ID, e.g., usr_...
    tenant_id VARCHAR(255) NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    email VARCHAR(255) NOT NULL,
    hashed_password VARCHAR(255) NOT NULL, -- 存储bcrypt哈希后的密码
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    UNIQUE(tenant_id, email) -- 确保在同一个租户内，邮箱是唯一的
);

-- 表: internal_clients
-- 描述: 注册内部微服务，用于M2M认证。
CREATE TABLE internal_clients (
    client_id VARCHAR(255) PRIMARY KEY, -- 服务的唯一标识符, e.g., 'job-service'
    client_secret_hash VARCHAR(255) NOT NULL, -- 服务密钥的bcrypt哈希值
    service_name VARCHAR(255) NOT NULL, -- 服务的可读名称
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- 表: scopes
-- 描述: 定义系统中所有可用的操作权限(Scope)。
CREATE TABLE scopes (
    id SERIAL PRIMARY KEY,
    scope_name VARCHAR(255) UNIQUE NOT NULL, -- e.g., 'credits:deduct'
    description TEXT
);

-- 表: client_scopes
-- 描述: 将服务(client)与其被授予的权限(scope)进行关联。
CREATE TABLE client_scopes (
    client_id VARCHAR(255) NOT NULL REFERENCES internal_clients(client_id) ON DELETE CASCADE,
    scope_id INT NOT NULL REFERENCES scopes(id) ON DELETE CASCADE,
    PRIMARY KEY (client_id, scope_id)
);
```

#### **4. API 端点设计**

所有API都遵循 `/v1/...` 的版本控制路径。

##### **4.1 对外公开API (IDaaS)**

- **`POST /v1/auth/register`**
    
    - **认证**: Public API Key (在请求头中提供，用于识别租户)。
        
    - **描述**: 为当前租户注册一个新用户。
        
    - **请求体**: `{ "email": "user@example.com", "password": "..." }`
        
    - **响应**: `{ "userId": "usr_...", "email": "..." }`
        
- **`POST /v1/auth/login`**
    
    - **认证**: Public API Key。
        
    - **描述**: 终端用户登录。
        
    - **请求体**: `{ "email": "user@example.com", "password": "..." }`
        
    - **响应**: `{ "token": "ey...", "expiresIn": 3600 }` (返回用户JWT)
        
- **`GET /v1/auth/me`**
    
    - **认证**: User JWT (Bearer Token)。
        
    - **描述**: 获取当前登录用户的信息。
        
    - **响应**: `{ "userId": "usr_...", "email": "...", "tenantId": "tnt_..." }`
        

##### **4.2 对内私有API (M2M)**

- **`POST /oauth/token`**
    
    - **认证**: Basic Auth (使用`client_id`和`client_secret`)。
        
    - **描述**: 内部微服务获取服务间通信的访问令牌。
        
    - **请求体**: `grant_type=client_credentials`
        
    - **响应**: `{ "access_token": "ey...", "token_type": "Bearer", "expires_in": 300 }` (返回服务JWT)
        

#### **5. 核心逻辑与安全实现**

- **密码与密钥安全**:
    
    - **绝不存储明文密码/密钥**。所有`hashed_password`和`api_secret_key_hash`字段都必须使用`bcrypt`进行哈希处理。
        
    - 登录或验证时，使用`bcrypt.CompareHashAndPassword`进行比较。
        
- **用户JWT签发**:
    
    - 登录成功后，生成一个包含以下关键载荷的JWT：
        
        ```
        {
          "sub": "usr_...",       // Subject (用户ID)
          "tid": "tnt_...",       // Tenant ID (租户ID)
          "exp": 1678886400,      // 过期时间 (例如1小时后)
          "iss": "https://auth.yoursaas.com" // 签发者
        }
        ```
        
    - 使用一个强密钥（从环境变量读取的`JWT_SECRET_KEY`）和`HMAC-SHA256`算法进行签名。
        
- **服务JWT签发**:
    
    - 在`/oauth/token`端点，验证`client_id`和`client_secret`后，从数据库查询该服务被授予的所有`scope`。
        
    - 生成一个包含以下关键载荷的JWT：
        
        ```
        {
          "sub": "job-management-service", // Subject (服务ID)
          "scope": "credits:deduct credits:refund", // 权限范围
          "exp": 1678883100,      // 短暂的过期时间 (例如5分钟)
          "iss": "https://auth.yoursaas.com"
        }
        ```
        
    - 使用**不同的密钥**（或非对称加密如RS256）进行签名，以区分用户JWT和服务JWT。
        

#### **6. 部署与配置 (Railway)**

- **部署**: 本服务作为一个独立的Go应用，使用自己的`Dockerfile`部署到Railway。
    
- **环境变量**:
    
    - `DATABASE_URL`: 由Railway自动注入的PostgreSQL连接字符串。
        
    - `PORT`: 由Railway自动注入的服务监听端口。
        
    - `JWT_USER_SECRET_KEY`: 用于签发**用户JWT**的强密钥。
        
    - `JWT_SERVICE_SECRET_KEY`: 用于签发**服务JWT**的强密钥。
        
    - `BCRYPT_COST`: bcrypt算法的计算强度，推荐值为12-14。
        

通过此方案，您将构建一个职责单一、高度安全、与系统其他部分完全解耦的认证服务，为您的SaaS平台提供坚如磐石的身份认证基础。